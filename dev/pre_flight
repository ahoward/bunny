#!/usr/bin/env bun
//
// pre_flight - checks before starting work
//
// returns Result<boolean> to stdout as JSON.
// exit 0 if all checks pass, exit 1 otherwise.
//

import type { Result, Meta } from "../src/lib/types.ts"
import { success, error } from "../src/lib/result.ts"

interface Check {
  name:    string
  ok:      boolean
  message: string | null
}

async function run_checks(): Promise<Check[]> {
  const checks: Check[] = []

  // 1. type check passes
  const tsc = Bun.spawn(["bunx", "tsc", "--noEmit"], { stdout: "pipe", stderr: "pipe" })
  const tsc_exit = await tsc.exited
  checks.push({
    name:    "type_check",
    ok:      tsc_exit === 0,
    message: tsc_exit === 0 ? null : "tsc --noEmit failed"
  })

  // 2. tests pass
  const test_proc = Bun.spawn(["bun", "test"], {
    stdout: "pipe",
    stderr: "pipe",
    env: { ...process.env, BUNNY_LOG: "0" }
  })
  const test_exit = await test_proc.exited
  checks.push({
    name:    "tests_pass",
    ok:      test_exit === 0,
    message: test_exit === 0 ? null : "bun test exited non-zero"
  })

  // 3. branch is clean
  const status_proc = Bun.spawn(["git", "status", "--porcelain"], { stdout: "pipe" })
  const status_text = await new Response(status_proc.stdout).text()
  const is_clean = status_text.trim() === ""
  checks.push({
    name:    "branch_clean",
    ok:      is_clean,
    message: is_clean ? null : "uncommitted changes detected"
  })

  // 4. roadmap item exists
  try {
    const roadmap = await Bun.file(".bny/roadmap.md").text()
    const has_next = roadmap.includes("- [ ]") && !roadmap.includes("*your-first-feature*")
    checks.push({
      name:    "roadmap_item",
      ok:      has_next,
      message: has_next ? null : "no actionable roadmap item found"
    })
  } catch {
    checks.push({
      name:    "roadmap_item",
      ok:      false,
      message: ".bny/roadmap.md not found"
    })
  }

  return checks
}

const start = performance.now()
const checks = await run_checks()
const all_ok = checks.every(c => c.ok)

const meta: Meta = {
  path:        "/dev/pre_flight",
  timestamp:   new Date().toISOString(),
  duration_ms: Math.round((performance.now() - start) * 1000) / 1000
}

const result: Result<{ ok: boolean; checks: Check[] }> = all_ok
  ? success({ ok: true, checks }, meta)
  : {
      ...error(
        Object.fromEntries(
          checks.filter(c => !c.ok).map(c => [
            c.name,
            [{ code: "pre_flight_failed", message: c.message ?? "check failed" }]
          ])
        ),
        meta
      ),
      result: { ok: false, checks }
    } as Result<{ ok: boolean; checks: Check[] }>

process.stdout.write(JSON.stringify(result, null, 2) + "\n")
process.exit(all_ok ? 0 : 1)
