#!/usr/bin/env bun
//
// bny next — pick the next roadmap item and run the full pipeline
//
// reads .bny/roadmap.md, extracts the first unchecked item,
// and orchestrates: specify → (human reviews spec) → plan → tasks →
// review → implement → post_flight → update roadmap + decisions
//
// usage:
//   bny next                    # run the pipeline
//   bny next --dry-run          # show what would run
//   bny next --max-iter 10      # ralph iterations for implement
//

import { existsSync, readFileSync, writeFileSync } from "node:fs"
import { resolve } from "node:path"
import { find_root } from "./lib/feature.ts"

// -- parse args --

const argv = process.argv.slice(2)
let dry_run = false
let auto_mode = false
let max_iter = 5

for (let i = 0; i < argv.length; i++) {
  const arg = argv[i]
  if (arg === "--dry-run") {
    dry_run = true
  } else if (arg === "--auto") {
    auto_mode = true
  } else if (arg === "--max-iter" && argv[i + 1]) {
    max_iter = parseInt(argv[i + 1], 10)
    i++
  } else if (arg === "--help" || arg === "-h") {
    process.stdout.write(`usage: bny next [--dry-run] [--auto] [--max-iter N]

picks the next roadmap item and runs the full pipeline:
  1. pre_flight
  2. specify (create branch + spec)
  3. human reviews spec (skipped in --auto)
  4. plan
  5. tasks
  6. review (gemini)
  7. implement (claude, with ralph)
  8. post_flight
  9. update roadmap + decisions
  10. report

flags:
  --dry-run       show what would run, don't execute
  --auto          skip human checkpoints (for bny spin)
  --max-iter N    ralph iterations for implement (default: 5)
`)
    process.exit(0)
  }
}

// -- setup --

const root = find_root()

// -- parse roadmap --

const roadmap_path = resolve(root, ".bny/roadmap.md")
if (!existsSync(roadmap_path)) {
  process.stderr.write("error: .bny/roadmap.md not found\n")
  process.exitCode = 1
  process.exit()
}

const roadmap = readFileSync(roadmap_path, "utf-8")

// find ## Next section, extract first unchecked item
const next_match = roadmap.match(/## Next\n\n([\s\S]*?)(?=\n## |\n*$)/)
if (!next_match) {
  process.stderr.write("error: no '## Next' section in roadmap\n")
  process.exitCode = 1
  process.exit()
}

const next_section = next_match[1]
const item_match = next_section.match(/^- \[ \] (.+)$/m)
if (!item_match) {
  process.stderr.write("nothing to do — all roadmap items completed\n")
  process.exit(0)
}

const item_text = item_match[1].trim()
// split on " — " to get name and description
const dash_idx = item_text.indexOf(" — ")
const item_name = dash_idx >= 0 ? item_text.slice(0, dash_idx).trim() : item_text
const item_desc = dash_idx >= 0 ? item_text.slice(dash_idx + 3).trim() : item_text

process.stderr.write(`\n[bny next]\n`)
process.stderr.write(`  item: ${item_text}\n`)
process.stderr.write(`  max-iter: ${max_iter}\n\n`)

if (dry_run) {
  process.stderr.write(`would run:\n`)
  process.stderr.write(`  1. ./dev/pre_flight\n`)
  process.stderr.write(`  2. bny specify "${item_name}"\n`)
  process.stderr.write(`  3. (human reviews spec)\n`)
  process.stderr.write(`  4. bny plan\n`)
  process.stderr.write(`  5. bny tasks\n`)
  process.stderr.write(`  6. bny review\n`)
  process.stderr.write(`  7. bny --ralph --max-iter ${max_iter} implement\n`)
  process.stderr.write(`  8. ./dev/post_flight\n`)
  process.stderr.write(`  9. update roadmap + decisions\n`)
  process.stderr.write(` 10. report\n`)
  process.exit(0)
}

// -- helpers --

function run(cmd: string[], label: string): boolean {
  process.stderr.write(`\n--- ${label} ---\n`)
  const proc = Bun.spawnSync(cmd, {
    stdout: "inherit",
    stderr: "inherit",
    stdin: "inherit",
    cwd: root,
  })
  if (proc.exitCode !== 0) {
    process.stderr.write(`\nerror: ${label} failed (exit ${proc.exitCode})\n`)
    return false
  }
  return true
}

function confirm(prompt: string): boolean {
  process.stderr.write(prompt)
  const buf = Buffer.alloc(64)
  const fd = require("node:fs").openSync("/dev/tty", "r")
  const n = require("node:fs").readSync(fd, buf, 0, 64)
  require("node:fs").closeSync(fd)
  const answer = buf.slice(0, n).toString().trim().toLowerCase()
  return answer === "" || answer === "y" || answer === "yes"
}

// -- 1. pre_flight --

if (!run(["./dev/pre_flight"], "pre_flight")) {
  process.exitCode = 1
  process.exit()
}

// -- 2. specify --

if (!run(["bun", resolve(root, "bny/specify"), item_name], "specify")) {
  process.exitCode = 1
  process.exit()
}

// find the spec file that was just created
const { current_feature, feature_paths } = await import("./lib/feature.ts")
const feature = current_feature()
if (!feature) {
  process.stderr.write("error: could not determine feature branch after specify\n")
  process.exitCode = 1
  process.exit()
}

const paths = feature_paths(root, feature)

// -- 3. human reviews spec --

if (!auto_mode) {
  process.stderr.write(`\n--- human checkpoint ---\n`)
  process.stderr.write(`spec: ${paths.spec}\n`)
  process.stderr.write(`\nreview the spec, edit if needed.\n`)

  if (!confirm("continue? [Y/n] ")) {
    process.stderr.write("aborted by human\n")
    process.exit(0)
  }
} else {
  process.stderr.write(`\n--- auto: skipping spec review ---\n`)
}

// -- 4. plan --

if (!run(["bun", resolve(root, "bny/plan")], "plan")) {
  process.exitCode = 1
  process.exit()
}

// -- 5. tasks --

if (!run(["bun", resolve(root, "bny/tasks")], "tasks")) {
  process.exitCode = 1
  process.exit()
}

// -- 6. review (gemini) --

if (!run(["bun", resolve(root, "bny/review")], "review")) {
  // review failure is non-fatal — gemini might not be available
  process.stderr.write("warning: review failed, continuing without antagonist review\n")
}

// -- 7. implement (claude, with ralph) --

const impl_cmd = ["bun", resolve(root, "bin/bny"), "--ralph", "--max-iter", String(max_iter), "implement"]
if (!run(impl_cmd, `implement (ralph, max-iter ${max_iter})`)) {
  if (!auto_mode) {
    process.stderr.write(`\nimplementation did not complete cleanly.\n`)
    if (!confirm("continue anyway? [y/N] ")) {
      process.stderr.write("stopped at implement\n")
      process.exitCode = 1
      process.exit()
    }
  } else {
    process.stderr.write(`\nauto: implementation did not complete cleanly, continuing\n`)
  }
}

// -- 8. post_flight --

if (!run(["./dev/post_flight"], "post_flight")) {
  process.stderr.write("warning: post_flight failed\n")
}

// -- 9. update roadmap + decisions --

process.stderr.write(`\n--- updating roadmap + decisions ---\n`)

// check off the item in roadmap
const updated_roadmap = roadmap.replace(
  `- [ ] ${item_text}`,
  `- [x] ${item_text}`
)
writeFileSync(roadmap_path, updated_roadmap)
process.stderr.write(`roadmap: checked off '${item_name}'\n`)

// append to decisions
const decisions_path = resolve(root, ".bny/decisions.md")
if (existsSync(decisions_path)) {
  const today = new Date().toISOString().slice(0, 10)
  const decisions = readFileSync(decisions_path, "utf-8")
  const row = `| ${today} | ${item_name} | Built via bny next (strange loop iteration) |\n`
  writeFileSync(decisions_path, decisions.trimEnd() + "\n" + row)
  process.stderr.write(`decisions: appended '${item_name}'\n`)
}

// -- 10. report --

process.stderr.write(`\n[bny next] complete: ${item_text}\n`)
