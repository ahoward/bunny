#!/usr/bin/env bun
//
// bny spin — launch an autonomous factory run, detached
//
// spawns bny next --auto in a tmux session with a clean env.
// returns immediately. the factory runs in the background.
//
// usage:
//   bny spin                    # pick roadmap item, run detached
//   bny spin --attach           # launch and attach to watch
//   bny spin --max-iter 10      # more ralph retries
//   bny spin --dry-run          # show what would run
//   bny spin --log              # tail the latest spin log
//

import { existsSync, mkdirSync, readFileSync, readdirSync, symlinkSync, unlinkSync } from "node:fs"
import { resolve, basename } from "node:path"
import { find_root } from "./lib/feature.ts"

// -- parse args --

const argv = process.argv.slice(2)
let attach = false
let dry_run = false
let show_log = false
let max_iter = 5

for (let i = 0; i < argv.length; i++) {
  const arg = argv[i]
  if (arg === "--attach" || arg === "-a") {
    attach = true
  } else if (arg === "--dry-run") {
    dry_run = true
  } else if (arg === "--log" || arg === "-l") {
    show_log = true
  } else if (arg === "--max-iter" && argv[i + 1]) {
    max_iter = parseInt(argv[i + 1], 10)
    i++
  } else if (arg === "--help" || arg === "-h") {
    process.stdout.write(`usage: bny spin [--attach] [--dry-run] [--log] [--max-iter N]

launches bny next --auto in a detached tmux session.
the factory runs autonomously — review the output after.

flags:
  --attach, -a    launch and attach (watch live)
  --dry-run       show what would launch
  --log, -l       tail the latest spin log
  --max-iter N    ralph iterations for implement (default: 5)

workflow:
  bny spin                                  # factory runs
  bny spin --log                            # watch progress
  cat .bny/spin/latest.log                  # review output
  echo "feedback" > feedback.md             # write feedback
  bny brane eat feedback.md                 # feed back into brane
  bny spin                                  # next iteration
`)
    process.exit(0)
  }
}

// -- setup --

const root = find_root()
const spin_dir = resolve(root, ".bny/spin")
mkdirSync(spin_dir, { recursive: true })

// -- log mode --

if (show_log) {
  const latest = resolve(spin_dir, "latest.log")
  if (!existsSync(latest)) {
    process.stderr.write("no spin logs yet\n")
    process.exit(0)
  }
  const proc = Bun.spawnSync(["tail", "-f", latest], {
    stdout: "inherit",
    stderr: "inherit",
    stdin: "inherit",
  })
  process.exit(proc.exitCode ?? 0)
}

// -- check tmux --

const tmux_check = Bun.spawnSync(["which", "tmux"], { stdout: "pipe", stderr: "pipe" })
if (tmux_check.exitCode !== 0) {
  process.stderr.write("error: tmux not found — install with: brew install tmux\n")
  process.exitCode = 1
  process.exit()
}

// -- parse roadmap to get session name --

const roadmap_path = resolve(root, ".bny/roadmap.md")
if (!existsSync(roadmap_path)) {
  process.stderr.write("error: .bny/roadmap.md not found\n")
  process.exitCode = 1
  process.exit()
}

const roadmap = readFileSync(roadmap_path, "utf-8")
const next_match = roadmap.match(/## Next\n\n([\s\S]*?)(?=\n## |\n*$)/)
if (!next_match) {
  process.stderr.write("error: no '## Next' section in roadmap\n")
  process.exitCode = 1
  process.exit()
}

const item_match = next_match[1].match(/^- \[ \] (.+)$/m)
if (!item_match) {
  process.stderr.write("nothing to do — all roadmap items completed\n")
  process.exit(0)
}

const item_text = item_match[1].trim()
const dash_idx = item_text.indexOf(" — ")
const item_name = dash_idx >= 0 ? item_text.slice(0, dash_idx).trim() : item_text
const session_slug = item_name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "")

// -- log file --

const ts = new Date().toISOString().replace(/[:.]/g, "-")
const log_file = resolve(spin_dir, `${ts}-${session_slug}.log`)
const latest_link = resolve(spin_dir, "latest.log")

// -- session name --

const session_name = `bny-spin-${session_slug}`

// check if already running
const session_check = Bun.spawnSync(["tmux", "has-session", "-t", session_name], {
  stdout: "pipe", stderr: "pipe"
})
if (session_check.exitCode === 0) {
  process.stderr.write(`already running: ${session_name}\n`)
  process.stderr.write(`  attach: tmux attach -t ${session_name}\n`)
  process.stderr.write(`  log:    bny spin --log\n`)
  process.exit(0)
}

// -- build command --

// clean env: strip CLAUDECODE, keep essentials
const clean_env: Record<string, string> = {}
for (const [k, v] of Object.entries(process.env)) {
  if (k === "CLAUDECODE") continue
  if (k === "CLAUDE_CODE_SESSION") continue
  if (v != null) clean_env[k] = v
}

const next_cmd = [
  "bun", resolve(root, "bny/next"),
  "--auto",
  "--max-iter", String(max_iter),
]

const shell_cmd = `${next_cmd.join(" ")} 2>&1 | tee ${log_file}`

// -- dry run --

if (dry_run) {
  process.stderr.write(`[bny spin] dry-run\n`)
  process.stderr.write(`  item:    ${item_text}\n`)
  process.stderr.write(`  session: ${session_name}\n`)
  process.stderr.write(`  log:     ${log_file}\n`)
  process.stderr.write(`  cmd:     ${shell_cmd}\n`)
  process.exit(0)
}

// -- update latest symlink --

try { unlinkSync(latest_link) } catch { /* ok */ }
symlinkSync(basename(log_file), latest_link)

// -- launch tmux session --

process.stderr.write(`[bny spin]\n`)
process.stderr.write(`  item:    ${item_text}\n`)
process.stderr.write(`  session: ${session_name}\n`)
process.stderr.write(`  log:     ${log_file}\n\n`)

const tmux_cmd = [
  "tmux", "new-session",
  "-d",
  "-s", session_name,
  "-x", "200", "-y", "50",
  "bash", "-c", shell_cmd,
]

const tmux_proc = Bun.spawnSync(tmux_cmd, {
  stdout: "inherit",
  stderr: "inherit",
  cwd: root,
  env: clean_env,
})

if (tmux_proc.exitCode !== 0) {
  process.stderr.write("error: failed to create tmux session\n")
  process.exitCode = 1
  process.exit()
}

process.stderr.write(`spinning...\n\n`)
process.stderr.write(`  watch:  tmux attach -t ${session_name}\n`)
process.stderr.write(`  log:    bny spin --log\n`)
process.stderr.write(`  ps:     bny ps\n`)

// -- attach if requested --

if (attach) {
  process.stderr.write(`\nattaching...\n`)
  const attach_proc = Bun.spawnSync(["tmux", "attach", "-t", session_name], {
    stdout: "inherit",
    stderr: "inherit",
    stdin: "inherit",
  })
  process.exit(attach_proc.exitCode ?? 0)
}
