#!/usr/bin/env bun
//
// bny brane enhance — convergent refinement of the worldview
//
// "enhance." looks at the existing worldview and sharpens it:
// fills gaps, removes redundancy, surfaces contradictions,
// deepens thin areas. goes INWARD — refines, not expands.
//
// usage:
//   bny brane enhance                        # enhance full worldview
//   bny brane enhance "api design"           # focus on a topic
//   bny brane enhance architecture.md        # focus on a specific file
//   bny brane enhance --rounds 3            # multi-round refinement
//   bny brane enhance --dry-run
//   bny brane enhance --yes
//

import { existsSync } from "node:fs"
import { resolve, relative } from "node:path"
import { success, error } from "../../src/lib/result.ts"
import { find_root } from "../lib/feature.ts"
import {
  ensure_brane, load_worldview, load_active_povs, worldview_dir,
  call_claude, parse_json, apply_operations,
  preview_operations, print_intake_diff, confirm_intake,
  regenerate_index,
} from "../lib/brane.ts"
import type { EatResponse } from "../lib/brane.ts"

// -- parse args --

const argv = process.argv.slice(2)
let dry_run = false
let auto_yes = false
let rounds = 1
const input_parts: string[] = []

for (let i = 0; i < argv.length; i++) {
  const arg = argv[i]
  if (arg === "--dry-run") {
    dry_run = true
  } else if (arg === "--yes" || arg === "-y") {
    auto_yes = true
  } else if (arg === "--rounds" && i + 1 < argv.length) {
    rounds = parseInt(argv[i + 1], 10)
    if (isNaN(rounds) || rounds < 1) rounds = 1
    i++
  } else if (arg === "--help" || arg === "-h") {
    process.stdout.write(`usage: bny brane enhance [--dry-run] [--yes] [--rounds N] [focus]

focus can be a topic string or a worldview file path.
if no focus is given, enhances the full worldview.

flags:
  --dry-run      print prompt, don't call claude
  --yes, -y      skip confirmation, apply immediately
  --rounds N     multi-round refinement (default: 1)
`)
    process.exit(0)
  } else {
    input_parts.push(arg)
  }
}

const focus_input = input_parts.join(" ").trim() || null

function meta() {
  return { path: "/bny/brane/enhance", timestamp: new Date().toISOString(), duration_ms: 0 }
}

// -- setup --

const root = find_root()
ensure_brane(root)

// -- guard: worldview must not be empty --

const initial_worldview = load_worldview(root)
if (initial_worldview.length === 0) {
  process.stdout.write(JSON.stringify(error({ worldview: [{ code: "empty", message: "worldview is empty — eat some information first" }] }, meta()), null, 2) + "\n")
  process.exitCode = 1
  process.exit()
}

// -- resolve focus --

let focus_label: string | null = null

if (focus_input) {
  // check if it's a worldview file path
  const as_wv_path = resolve(worldview_dir(root), focus_input)
  if (existsSync(as_wv_path)) {
    focus_label = relative(worldview_dir(root), as_wv_path)
  } else {
    // treat as a topic string
    focus_label = focus_input
  }
}

// -- check claude --

if (!dry_run) {
  const claude_check = Bun.spawnSync(["which", "claude"], { stdout: "pipe", stderr: "pipe" })
  if (claude_check.exitCode !== 0) {
    process.stdout.write(JSON.stringify(error({ claude: [{ code: "not_found", message: "claude CLI not found on PATH" }] }, meta()), null, 2) + "\n")
    process.exitCode = 1
    process.exit()
  }
}

// -- rounds --

let total_ops = 0

for (let round = 1; round <= rounds; round++) {
  if (rounds > 1) process.stderr.write(`\n[round ${round}/${rounds}]\n`)

  // reload each round
  const povs = load_active_povs(root)
  const worldview = load_worldview(root)

  const pov_block = povs.length > 0
    ? povs.map(p => `## ${p.heading}\n\n${p.content}`).join("\n\n")
    : "(no active points of view)"

  const worldview_block = worldview.map(w => `## ${w.heading}\n\n${w.content}`).join("\n\n")

  const focus_block = focus_label
    ? `\nFocus especially on: ${focus_label}\n`
    : ""

  const enhance_prompt = `# Points of View

${pov_block}

---

# Current Worldview

${worldview_block}

---

# Instructions

You are ENHANCING the worldview — going INWARD, not outward.
Make it sharper, more precise, more useful. Do NOT add new topics.

Review the current worldview and:
- Fill gaps: where is a topic mentioned but not developed?
- Remove redundancy: where do multiple files say the same thing?
- Surface contradictions: where do files disagree?
- Deepen: where are claims made without reasoning or evidence?
- Restructure: should any files be split, merged, or reorganized?
- Clarify: replace vague language with specific statements
${focus_block}
Respond with ONLY valid JSON (no markdown fences):
{
  "operations": [
    {"action": "create", "path": "relative/path.md", "content": "full markdown content"},
    {"action": "update", "path": "existing/path.md", "content": "full replacement content"}
  ],
  "reasoning": "what was refined and why"
}

Paths are relative to worldview/. Use lowercase-kebab-case for file and directory names.
If nothing needs refining, return empty operations with reasoning explaining why.
`

  // -- dry run --

  if (dry_run) {
    process.stdout.write(enhance_prompt + "\n")
    process.exit(0)
  }

  // -- call claude --

  process.stderr.write(`enhancing${focus_label ? `: ${focus_label}` : ""}...\n`)

  const raw = call_claude(enhance_prompt, root)
  if (!raw) {
    process.exitCode = 1
    process.exit()
  }

  let response = parse_json<EatResponse>(raw)
  if (!response) {
    process.stderr.write("warning: failed to parse response, retrying...\n")
    const retry = call_claude(enhance_prompt + "\n\nYour last response was not valid JSON. Try again. Raw JSON only, no markdown fences.", root)
    if (!retry) { process.exitCode = 1; process.exit() }
    response = parse_json<EatResponse>(retry)
    if (!response) {
      process.stdout.write(JSON.stringify(error({ parse: [{ code: "invalid_json", message: "could not get structured response from claude" }] }, meta()), null, 2) + "\n")
      process.exitCode = 1
      process.exit()
    }
  }

  // -- stop early --

  if (response.operations.length === 0) {
    process.stderr.write("nothing to refine\n")
    break
  }

  // -- intake gate --

  const diffs = preview_operations(root, response.operations)
  print_intake_diff(diffs, response.reasoning)

  if (!auto_yes) {
    if (!confirm_intake()) {
      process.stderr.write("aborted\n")
      process.exit(0)
    }
  }

  apply_operations(root, response.operations)
  process.stderr.write(`applied ${response.operations.length} operation(s)\n`)
  total_ops += response.operations.length

  await regenerate_index(root)
}

// -- output --

const result_data = {
  focus: focus_label,
  rounds,
  operations: total_ops,
}

process.stdout.write(JSON.stringify(success(result_data, meta()), null, 2) + "\n")
